from control import forced_response, poles, zeros
import numpy as np
from theoretical_cepstrum.mimo_cepstrum import generate_stable_mimo_system

from mimo_systems.cepstral_distance_mimo import compute_cepstral_distance


def generate_white_noise_signal(n_samples, n_inputs, mean, sigma, n_signals=1):
    if n_signals > 1:
        inputs = []
        for i in range(n_signals):
            inputs.append(np.random.normal(mean, sigma, size=(n_inputs, n_samples)))
        return inputs
    elif n_signals == 1:
        return np.random.normal(mean, sigma, size=(n_inputs, n_samples))


def generate_sinusoidal_signal(n_samples, freq, n_signals=1):
    # two inputs
    fs = 800
    Ts = 1 / fs
    n = np.arange(n_samples)
    if n_signals > 1:
        inputs = []
        for i in range(n_signals):
            u1 = 10 * np.sin(2 * np.pi * freq[0] * n * Ts) + np.random.normal(0, 0.2, size=n_samples)
            u2 = 2 * np.sin(2 * np.pi * freq[1] * n * Ts + np.pi/4) + np.random.normal(0, 0.6, size=n_samples)
            inputs.append(np.vstack((u1, u2)).T)
        return inputs
    elif n_signals == 1:
        u1 = 10 * np.sin(2 * np.pi * freq[0] * n * Ts) + np.random.normal(0, 0.2, size=n_samples)
        u2 = 2 * np.sin(2 * np.pi * freq[1] * n * Ts + np.pi / 4) + np.random.normal(0, 0.6, size=n_samples)
        return np.vstack((u1, u2)).T


def simulate_system_on_multiple_input(input_signals, system):
    output_signals = []
    t = np.arange(input_signals[0].shape[1])
    for input_signal in input_signals:
        _, y = forced_response(system, timepts=t, inputs=input_signal)
        output_signals.append(y)

    return output_signals


def compute_distance_between_mimo_systems():
    np.random.seed(5)
    sys_1, poles_1, zeros_1 = generate_stable_mimo_system(2, 10, 10)
    sys_2, poles_2, zeros_2 = generate_stable_mimo_system(2, 10, 10)
    print(f"Poles: {poles(sys_1)}")
    print(f"Zeros: {zeros(sys_1)}")
    u_1 = generate_white_noise_signal(2**14, 2, 0, 1)
    u_2 = generate_white_noise_signal(2**14, 2, 0, 1)
    t = np.arange(u_1.shape[1])
    _, y_11 = forced_response(sys_1, timepts=t, inputs=u_1)
    _, y_21 = forced_response(sys_2, timepts=t, inputs=u_1)
    _, y_12 = forced_response(sys_1, timepts=t, inputs=u_2)
    _, y_22 = forced_response(sys_2, timepts=t, inputs=u_2)

    print(f'Distance between time series generated by different systems: {compute_cepstral_distance(u_1, y_11, u_1, y_21)}')
    print(f'Distance between time series generated by systems 1: {compute_cepstral_distance(u_1, y_11, u_2, y_12)}')
    print(f'Distance between time series generated by systems 2: {compute_cepstral_distance(u_1, y_21, u_2, y_22)}')
